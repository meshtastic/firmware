# Отчет об аудите безопасности прошивки Meshtastic

## 1. Обзор безопасности
Проект использует современные криптографические протоколы (AES-256-CTR, Curve25519) и структурированную передачу данных через Protobuf. Однако в ходе аудита были выявлены критические участки кода, потенциально подверженные атакам, и архитектурные особенности интерфейсов внешнего управления.

## 2. Выявленные уязвимости и технические риски

### 2.1. Переполнение буфера в модуле MQTT
В файле `src/mqtt/MQTT.cpp` функция `publish` (при использовании `proxy_to_client_enabled`) использует небезопасный метод `strcpy` для копирования данных в буферы фиксированного размера.
- **Локация:** `src/mqtt/MQTT.cpp:478` и `479`.
- **Риск:** Если топик превысит 60 символов или текст сообщения превысит 435 символов, произойдет переполнение. Это может привести к сбою устройства или удаленному выполнению кода.

### 2.2. Риск Path Traversal (обход путей)
В модуле администрирования реализована возможность удаления файлов.
- **Локация:** `src/modules/AdminModule.cpp`.
- **Риск:** Отсутствует проверка на наличие символов `..` или `/` в именах файлов. Злоумышленник с правами администратора может попытаться удалить системные файлы вне стандартной директории данных.

### 2.3. Потенциальные коллизии Nonce в криптографии
Механизм формирования 16-байтного nonce для AES-CTR имеет пересекающиеся области.
- **Локация:** `src/mesh/CryptoEngine.cpp:261-267`.
- **Риск:** `extraNonce` перезаписывает часть `packetId` внутри nonce. При определенных значениях это может вызвать повторное использование nonce, что позволяет расшифровать трафик без знания ключа.

### 2.4. Использование PRNG для сессионных ключей
Ключи сессий администратора генерируются с помощью функции `random()`.
- **Локация:** `src/modules/AdminModule.cpp:1387`.
- **Риск:** Если PRNG не инициализирована качественной энтропией, сессионные ключи могут стать предсказуемыми, что позволит обойти авторизацию администратора.

### 2.5. Выделение памяти на стеке (VLA)
В обработке JSON MQTT используются массивы переменной длины.
- **Локация:** `src/mqtt/MQTT.cpp: onReceiveJson`.
- **Риск:** На устройствах с малым объемом ОЗУ (например, nRF52) длинное MQTT-сообщение (>1 КБ) может вызвать переполнение стека (Stack Overflow).

## 3. Анализ механизмов внешнего управления

### 3.1. Удаленное администрирование (AdminModule)
Позволяет менять любые настройки и выполнять сброс устройства.
- **Безопасность:** Зависит от владения ключами канала или PKI-ключами.
- **Угроза:** При использовании канала управления "по умолчанию" с публичным ключом, любой узел в сети может получить контроль над вашим устройством.

### 3.2. Удаленное управление оборудованием (RemoteHardware)
Позволяет манипулировать ножками процессора (GPIO).
- **Угроза:** Опция `allow_undefined_pin_access` позволяет злоумышленнику управлять любыми пинами, включая те, что отвечают за питание или сброс системы.

### 3.3. Доверие к локальным интерфейсам
По умолчанию команды через Serial (USB) и Bluetooth считаются доверенными.
- **Угроза:** Человек с физическим доступом к устройству может перехватить контроль, если не включен режим `is_managed`.

### 3.4. Удаленное выключение (Linux/Portduino)
Модуль `AdminModule` позволяет инжектировать события ввода (`handleSendInputEvent`). 
- **Угроза:** На Linux-системах (meshtasticd) инжекция события выключения может привести к вызову `system("poweroff")`, что позволяет удаленно выключать хост-машину.

## 4. Архитектурные особенности и риски "бекдоров"
- **Публичный ключ по умолчанию:** Канал "LongFast" использует общеизвестный ключ. Это не секретный вход, но отсутствие приватности на этом канале нужно учитывать.
- **Скрытая замена "sekrit":** В коде зарезервирована строка `sekrit` для защиты паролей от отображения. Однако механизм реализован непоследовательно: в `NETWORK_CONFIG` защита есть, а в `MQTT_CONFIG` пароли могут передаваться или затираться некорректно.
- **Выполнение произвольных команд (exec):** В модуле `HostMetrics.cpp` предусмотрено выполнение системной команды, заданной в конфигурации. Хотя это настройка хоста, ее наличие в коде прошивки является потенциальным вектором атаки при компрометации конфигурационных файлов.

## 5. Проблемы управления памятью и стабильности
- **Отсутствие проверки аллокаций:** В `RemoteHardwareModule` и других местах результат `allocDataProtobuf` используется без проверки на `NULL`. В условиях нехватки памяти это приведет к немедленному крэшу (DoS).
- **Фрагментация кучи:** В `CryptoEngine.cpp` объект `CTR` (AES) пересоздается (`delete`/`new`) для каждого отправляемого или получаемого пакета, что крайне неэффективно для эмбеддед-систем.

## 6. Итоговые рекомендации 
1. **Заменить все вызовы `strcpy` и `strncpy`** на `strlcpy` или аналоги с гарантированным zero-termination.
2. **Добавить проверку на NULL** после всех вызовов `alloc*` из пулов памяти.
3. **Исправить логику Nonce** в `CryptoEngine`, чтобы избежать перезатирания полей.
4. **Унифицировать защиту секретов** ("sekrit") для всех модулей, включая MQTT и WiFi.
5. **Для пользователей:** 
   - Всегда устанавливайте собственный PSK на каналы.
   - Используйте `is_managed = true` для защиты от атак через физический доступ.
   - Ограничивайте список доступных GPIO пинов в `RemoteHardware`.
