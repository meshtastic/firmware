/* Automatically generated nanopb header */
/* Generated by nanopb-0.4.7 */

#ifndef PB_MESH_PB_H_INCLUDED
#define PB_MESH_PB_H_INCLUDED
#include <pb.h>
#include "channel.pb.h"
#include "config.pb.h"
#include "module_config.pb.h"
#include "portnums.pb.h"
#include "telemetry.pb.h"

#if PB_PROTO_HEADER_VERSION != 40
#error Regenerate this file with the current version of nanopb generator.
#endif

/* Enum definitions */
/* Note: these enum names must EXACTLY match the string used in the device
 bin/build-all.sh script.
 Because they will be used to find firmware filenames in the android app for OTA updates.
 To match the old style filenames, _ is converted to -, p is converted to . */
typedef enum _HardwareModel {
    /* TODO: REPLACE */
    HardwareModel_UNSET = 0,
    /* TODO: REPLACE */
    HardwareModel_TLORA_V2 = 1,
    /* TODO: REPLACE */
    HardwareModel_TLORA_V1 = 2,
    /* TODO: REPLACE */
    HardwareModel_TLORA_V2_1_1P6 = 3,
    /* TODO: REPLACE */
    HardwareModel_TBEAM = 4,
    /* The original heltec WiFi_Lora_32_V2, which had battery voltage sensing hooked to GPIO 13
 (see HELTEC_V2 for the new version). */
    HardwareModel_HELTEC_V2_0 = 5,
    /* TODO: REPLACE */
    HardwareModel_TBEAM_V0P7 = 6,
    /* TODO: REPLACE */
    HardwareModel_T_ECHO = 7,
    /* TODO: REPLACE */
    HardwareModel_TLORA_V1_1P3 = 8,
    /* TODO: REPLACE */
    HardwareModel_RAK4631 = 9,
    /* The new version of the heltec WiFi_Lora_32_V2 board that has battery sensing hooked to GPIO 37.
 Sadly they did not update anything on the silkscreen to identify this board */
    HardwareModel_HELTEC_V2_1 = 10,
    /* Ancient heltec WiFi_Lora_32 board */
    HardwareModel_HELTEC_V1 = 11,
    /* New T-BEAM with ESP32-S3 CPU */
    HardwareModel_LILYGO_TBEAM_S3_CORE = 12,
    /* RAK WisBlock ESP32 core: https://docs.rakwireless.com/Product-Categories/WisBlock/RAK11200/Overview/ */
    HardwareModel_RAK11200 = 13,
    /* B&Q Consulting Nano Edition G1: https://uniteng.com/wiki/doku.php?id=meshtastic:nano */
    HardwareModel_NANO_G1 = 14,
    /* TODO: REPLACE */
    HardwareModel_TLORA_V2_1_1P8 = 15,
    /* TODO: REPLACE */
    HardwareModel_TLORA_T3_S3 = 16,
    /* B&Q Consulting Station Edition G1: https://uniteng.com/wiki/doku.php?id=meshtastic:station */
    HardwareModel_STATION_G1 = 25,
    /* Less common/prototype boards listed here (needs one more byte over the air) */
    HardwareModel_LORA_RELAY_V1 = 32,
    /* TODO: REPLACE */
    HardwareModel_NRF52840DK = 33,
    /* TODO: REPLACE */
    HardwareModel_PPR = 34,
    /* TODO: REPLACE */
    HardwareModel_GENIEBLOCKS = 35,
    /* TODO: REPLACE */
    HardwareModel_NRF52_UNKNOWN = 36,
    /* TODO: REPLACE */
    HardwareModel_PORTDUINO = 37,
    /* The simulator built into the android app */
    HardwareModel_ANDROID_SIM = 38,
    /* Custom DIY device based on @NanoVHF schematics: https://github.com/NanoVHF/Meshtastic-DIY/tree/main/Schematics */
    HardwareModel_DIY_V1 = 39,
    /* nRF52840 Dongle : https://www.nordicsemi.com/Products/Development-hardware/nrf52840-dongle/ */
    HardwareModel_NRF52840_PCA10059 = 40,
    /* Custom Disaster Radio esp32 v3 device https://github.com/sudomesh/disaster-radio/tree/master/hardware/board_esp32_v3 */
    HardwareModel_DR_DEV = 41,
    /* M5 esp32 based MCU modules with enclosure, TFT and LORA Shields. All Variants (Basic, Core, Fire, Core2, Paper) https://m5stack.com/ */
    HardwareModel_M5STACK = 42,
    /* New Heltec LoRA32 with ESP32-S3 CPU */
    HardwareModel_HELTEC_V3 = 43,
    /* New Heltec Wireless Stick Lite with ESP32-S3 CPU */
    HardwareModel_HELTEC_WSL_V3 = 44,
    /* Reserved ID For developing private Ports. These will show up in live traffic sparsely, so we can use a high number. Keep it within 8 bits. */
    HardwareModel_PRIVATE_HW = 255
} HardwareModel;

/* Shared constants between device and phone */
typedef enum _Constants {
    /* First enum must be zero, and we are just using this enum to
 pass int constants between two very different environments */
    Constants_ZERO = 0,
    /* From mesh.options
 note: this payload length is ONLY the bytes that are sent inside of the Data protobuf (excluding protobuf overhead). The 16 byte header is
 outside of this envelope */
    Constants_DATA_PAYLOAD_LEN = 237
} Constants;

/* Error codes for critical errors
 The device might report these fault codes on the screen.
 If you encounter a fault code, please post on the meshtastic.discourse.group
 and we'll try to help. */
typedef enum _CriticalErrorCode {
    /* TODO: REPLACE */
    CriticalErrorCode_NONE = 0,
    /* A software bug was detected while trying to send lora */
    CriticalErrorCode_TX_WATCHDOG = 1,
    /* A software bug was detected on entry to sleep */
    CriticalErrorCode_SLEEP_ENTER_WAIT = 2,
    /* No Lora radio hardware could be found */
    CriticalErrorCode_NO_RADIO = 3,
    /* Not normally used */
    CriticalErrorCode_UNSPECIFIED = 4,
    /* We failed while configuring a UBlox GPS */
    CriticalErrorCode_UBLOX_UNIT_FAILED = 5,
    /* This board was expected to have a power management chip and it is missing or broken */
    CriticalErrorCode_NO_AXP192 = 6,
    /* The channel tried to set a radio setting which is not supported by this chipset,
 radio comms settings are now undefined. */
    CriticalErrorCode_INVALID_RADIO_SETTING = 7,
    /* Radio transmit hardware failure. We sent data to the radio chip, but it didn't
 reply with an interrupt. */
    CriticalErrorCode_TRANSMIT_FAILED = 8,
    /* We detected that the main CPU voltage dropped below the minumum acceptable value */
    CriticalErrorCode_BROWNOUT = 9,
    /* Selftest of SX1262 radio chip failed */
    CriticalErrorCode_SX1262_FAILURE = 10,
    /* A (likely software but possibly hardware) failure was detected while trying to send packets.
 If this occurs on your board, please post in the forum so that we can ask you to collect some information to allow fixing this bug */
    CriticalErrorCode_RADIO_SPI_BUG = 11
} CriticalErrorCode;

/* How the location was acquired: manual, onboard GPS, external (EUD) GPS */
typedef enum _Position_LocSource {
    /* TODO: REPLACE */
    Position_LocSource_LOC_UNSET = 0,
    /* TODO: REPLACE */
    Position_LocSource_LOC_MANUAL = 1,
    /* TODO: REPLACE */
    Position_LocSource_LOC_INTERNAL = 2,
    /* TODO: REPLACE */
    Position_LocSource_LOC_EXTERNAL = 3
} Position_LocSource;

/* How the altitude was acquired: manual, GPS int/ext, etc
 Default: same as location_source if present */
typedef enum _Position_AltSource {
    /* TODO: REPLACE */
    Position_AltSource_ALT_UNSET = 0,
    /* TODO: REPLACE */
    Position_AltSource_ALT_MANUAL = 1,
    /* TODO: REPLACE */
    Position_AltSource_ALT_INTERNAL = 2,
    /* TODO: REPLACE */
    Position_AltSource_ALT_EXTERNAL = 3,
    /* TODO: REPLACE */
    Position_AltSource_ALT_BAROMETRIC = 4
} Position_AltSource;

/* A failure in delivering a message (usually used for routing control messages, but might be provided in addition to ack.fail_id to provide
 details on the type of failure). */
typedef enum _Routing_Error {
    /* This message is not a failure */
    Routing_Error_NONE = 0,
    /* Our node doesn't have a route to the requested destination anymore. */
    Routing_Error_NO_ROUTE = 1,
    /* We received a nak while trying to forward on your behalf */
    Routing_Error_GOT_NAK = 2,
    /* TODO: REPLACE */
    Routing_Error_TIMEOUT = 3,
    /* No suitable interface could be found for delivering this packet */
    Routing_Error_NO_INTERFACE = 4,
    /* We reached the max retransmission count (typically for naive flood routing) */
    Routing_Error_MAX_RETRANSMIT = 5,
    /* No suitable channel was found for sending this packet (i.e. was requested channel index disabled?) */
    Routing_Error_NO_CHANNEL = 6,
    /* The packet was too big for sending (exceeds interface MTU after encoding) */
    Routing_Error_TOO_LARGE = 7,
    /* The request had want_response set, the request reached the destination node, but no service on that node wants to send a response
 (possibly due to bad channel permissions) */
    Routing_Error_NO_RESPONSE = 8,
    /* Cannot send currently because duty cycle regulations will be violated. */
    Routing_Error_DUTY_CYCLE_LIMIT = 9,
    /* The application layer service on the remote node received your request, but considered your request somehow invalid */
    Routing_Error_BAD_REQUEST = 32,
    /* The application layer service on the remote node received your request, but considered your request not authorized
 (i.e you did not send the request on the required bound channel) */
    Routing_Error_NOT_AUTHORIZED = 33
} Routing_Error;

/* The priority of this message for sending.
 Higher priorities are sent first (when managing the transmit queue).
 This field is never sent over the air, it is only used internally inside of a local device node.
 API clients (either on the local node or connected directly to the node)
 can set this parameter if necessary.
 (values must be <= 127 to keep protobuf field to one byte in size.
 Detailed background on this field:
 I noticed a funny side effect of lora being so slow: Usually when making
 a protocol there isn’t much need to use message priority to change the order
 of transmission (because interfaces are fairly fast).
 But for lora where packets can take a few seconds each, it is very important
 to make sure that critical packets are sent ASAP.
 In the case of meshtastic that means we want to send protocol acks as soon as possible
 (to prevent unneeded retransmissions), we want routing messages to be sent next,
 then messages marked as reliable and finally ‘background’ packets like periodic position updates.
 So I bit the bullet and implemented a new (internal - not sent over the air)
 field in MeshPacket called ‘priority’.
 And the transmission queue in the router object is now a priority queue. */
typedef enum _MeshPacket_Priority {
    /* Treated as Priority.DEFAULT */
    MeshPacket_Priority_UNSET = 0,
    /* TODO: REPLACE */
    MeshPacket_Priority_MIN = 1,
    /* Background position updates are sent with very low priority -
 if the link is super congested they might not go out at all */
    MeshPacket_Priority_BACKGROUND = 10,
    /* This priority is used for most messages that don't have a priority set */
    MeshPacket_Priority_DEFAULT = 64,
    /* If priority is unset but the message is marked as want_ack,
 assume it is important and use a slightly higher priority */
    MeshPacket_Priority_RELIABLE = 70,
    /* Ack/naks are sent with very high priority to ensure that retransmission
 stops as soon as possible */
    MeshPacket_Priority_ACK = 120,
    /* TODO: REPLACE */
    MeshPacket_Priority_MAX = 127
} MeshPacket_Priority;

/* Identify if this is a delayed packet */
typedef enum _MeshPacket_Delayed {
    /* If unset, the message is being sent in real time. */
    MeshPacket_Delayed_NO_DELAY = 0,
    /* The message is delayed and was originally a broadcast */
    MeshPacket_Delayed_DELAYED_BROADCAST = 1,
    /* The message is delayed and was originally a direct message */
    MeshPacket_Delayed_DELAYED_DIRECT = 2
} MeshPacket_Delayed;

/* Log levels, chosen to match python logging conventions. */
typedef enum _LogRecord_Level {
    /* Log levels, chosen to match python logging conventions. */
    LogRecord_Level_UNSET = 0,
    /* Log levels, chosen to match python logging conventions. */
    LogRecord_Level_CRITICAL = 50,
    /* Log levels, chosen to match python logging conventions. */
    LogRecord_Level_ERROR = 40,
    /* Log levels, chosen to match python logging conventions. */
    LogRecord_Level_WARNING = 30,
    /* Log levels, chosen to match python logging conventions. */
    LogRecord_Level_INFO = 20,
    /* Log levels, chosen to match python logging conventions. */
    LogRecord_Level_DEBUG = 10,
    /* Log levels, chosen to match python logging conventions. */
    LogRecord_Level_TRACE = 5
} LogRecord_Level;

/* Struct definitions */
/* a gps position */
typedef struct _Position {
    /* The new preferred location encoding, multiply by 1e-7 to get degrees
 in floating point */
    int32_t latitude_i;
    /* TODO: REPLACE */
    int32_t longitude_i;
    /* In meters above MSL (but see issue #359) */
    int32_t altitude;
    /* This is usually not sent over the mesh (to save space), but it is sent
 from the phone so that the local device can set its RTC If it is sent over
 the mesh (because there are devices on the mesh without GPS), it will only
 be sent by devices which has a hardware GPS clock.
 seconds since 1970 */
    uint32_t time;
    /* TODO: REPLACE */
    Position_LocSource location_source;
    /* TODO: REPLACE */
    Position_AltSource altitude_source;
    /* Positional timestamp (actual timestamp of GPS solution) in integer epoch seconds */
    uint32_t timestamp;
    /* Pos. timestamp milliseconds adjustment (rarely available or required) */
    int32_t timestamp_millis_adjust;
    /* HAE altitude in meters - can be used instead of MSL altitude */
    int32_t altitude_hae;
    /* Geoidal separation in meters */
    int32_t altitude_geoidal_separation;
    /* Horizontal, Vertical and Position Dilution of Precision, in 1/100 units
 - PDOP is sufficient for most cases
 - for higher precision scenarios, HDOP and VDOP can be used instead,
   in which case PDOP becomes redundant (PDOP=sqrt(HDOP^2 + VDOP^2))
 TODO: REMOVE/INTEGRATE */
    uint32_t PDOP;
    /* TODO: REPLACE */
    uint32_t HDOP;
    /* TODO: REPLACE */
    uint32_t VDOP;
    /* GPS accuracy (a hardware specific constant) in mm
   multiplied with DOP to calculate positional accuracy
 Default: "'bout three meters-ish" :) */
    uint32_t gps_accuracy;
    /* Ground speed in m/s and True North TRACK in 1/100 degrees
 Clarification of terms:
 - "track" is the direction of motion (measured in horizontal plane)
 - "heading" is where the fuselage points (measured in horizontal plane)
 - "yaw" indicates a relative rotation about the vertical axis
 TODO: REMOVE/INTEGRATE */
    uint32_t ground_speed;
    /* TODO: REPLACE */
    uint32_t ground_track;
    /* GPS fix quality (from NMEA GxGGA statement or similar) */
    uint32_t fix_quality;
    /* GPS fix type 2D/3D (from NMEA GxGSA statement) */
    uint32_t fix_type;
    /* GPS "Satellites in View" number */
    uint32_t sats_in_view;
    /* Sensor ID - in case multiple positioning sensors are being used */
    uint32_t sensor_id;
    /* Estimated/expected time (in seconds) until next update:
 - if we update at fixed intervals of X seconds, use X
 - if we update at dynamic intervals (based on relative movement etc),
   but "AT LEAST every Y seconds", use Y */
    uint32_t next_update;
    /* A sequence number, incremented with each Position message to help
   detect lost updates if needed */
    uint32_t seq_number;
} Position;

/* Broadcast when a newly powered mesh node wants to find a node num it can use
 Sent from the phone over bluetooth to set the user id for the owner of this node.
 Also sent from nodes to each other when a new node signs on (so all clients can have this info)
 The algorithm is as follows:
 when a node starts up, it broadcasts their user and the normal flow is for all
 other nodes to reply with their User as well (so the new node can build its nodedb)
 If a node ever receives a User (not just the first broadcast) message where
 the sender node number equals our node number, that indicates a collision has
 occurred and the following steps should happen:
 If the receiving node (that was already in the mesh)'s macaddr is LOWER than the
 new User who just tried to sign in: it gets to keep its nodenum.
 We send a broadcast message of OUR User (we use a broadcast so that the other node can
 receive our message, considering we have the same id - it also serves to let
 observers correct their nodedb) - this case is rare so it should be okay.
 If any node receives a User where the macaddr is GTE than their local macaddr,
 they have been vetoed and should pick a new random nodenum (filtering against
 whatever it knows about the nodedb) and rebroadcast their User.
 A few nodenums are reserved and will never be requested:
 0xff - broadcast
 0 through 3 - for future use */
typedef struct _User {
    /* A globally unique ID string for this user.
 In the case of Signal that would mean +16504442323, for the default macaddr derived id it would be !<8 hexidecimal bytes>.
 Note: app developers are encouraged to also use the following standard
 node IDs "^all" (for broadcast), "^local" (for the locally connected node) */
    char id[16];
    /* A full name for this user, i.e. "Kevin Hester" */
    char long_name[40];
    /* A VERY short name, ideally two characters.
 Suitable for a tiny OLED screen */
    char short_name[5];
    /* This is the addr of the radio.
 Not populated by the phone, but added by the esp32 when broadcasting */
    pb_byte_t macaddr[6];
    /* TBEAM, HELTEC, etc...
 Starting in 1.2.11 moved to hw_model enum in the NodeInfo object.
 Apps will still need the string here for older builds
 (so OTA update can find the right image), but if the enum is available it will be used instead. */
    HardwareModel hw_model;
    /* In some regions Ham radio operators have different bandwidth limitations than others.
 If this user is a licensed operator, set this flag.
 Also, "long_name" should be their licence number. */
    bool is_licensed;
} User;

/* A message used in our Dynamic Source Routing protocol (RFC 4728 based) */
typedef struct _RouteDiscovery {
    /* The list of nodenums this packet has visited so far */
    pb_size_t route_count;
    uint32_t route[8];
} RouteDiscovery;

/* A Routing control Data packet handled by the routing module */
typedef struct _Routing {
    pb_size_t which_variant;
    union {
        /* A route request going from the requester */
        RouteDiscovery route_request;
        /* A route reply */
        RouteDiscovery route_reply;
        /* A failure in delivering a message (usually used for routing control messages, but might be provided
     in addition to ack.fail_id to provide details on the type of failure). */
        Routing_Error error_reason;
    };
} Routing;

typedef PB_BYTES_ARRAY_T(237) Data_payload_t;
/* (Formerly called SubPacket)
 The payload portion fo a packet, this is the actual bytes that are sent
 inside a radio packet (because from/to are broken out by the comms library) */
typedef struct _Data {
    /* Formerly named typ and of type Type */
    PortNum portnum;
    /* TODO: REPLACE */
    Data_payload_t payload;
    /* Not normally used, but for testing a sender can request that recipient
 responds in kind (i.e. if it received a position, it should unicast back it's position).
 Note: that if you set this on a broadcast you will receive many replies. */
    bool want_response;
    /* The address of the destination node.
 This field is is filled in by the mesh radio device software, application
 layer software should never need it.
 RouteDiscovery messages _must_ populate this.
 Other message types might need to if they are doing multihop routing. */
    uint32_t dest;
    /* The address of the original sender for this message.
 This field should _only_ be populated for reliable multihop packets (to keep
 packets small). */
    uint32_t source;
    /* Only used in routing or response messages.
 Indicates the original message ID that this message is reporting failure on. (formerly called original_id) */
    uint32_t request_id;
    /* If set, this message is intened to be a reply to a previously sent message with the defined id. */
    uint32_t reply_id;
    /* Defaults to false. If true, then what is in the payload should be treated as an emoji like giving
 a message a heart or poop emoji. */
    uint32_t emoji;
} Data;

/* Waypoint message, used to share arbitrary locations across the mesh */
typedef struct _Waypoint {
    /* Id of the waypoint */
    uint32_t id;
    /* latitude_i */
    int32_t latitude_i;
    /* longitude_i */
    int32_t longitude_i;
    /* Time the waypoint is to expire (epoch) */
    uint32_t expire;
    /* If true, only allow the original sender to update the waypoint. */
    bool locked;
    /* Name of the waypoint - max 30 chars */
    char name[30];
    /* *
 Description of the waypoint - max 100 chars */
    char description[100];
} Waypoint;

typedef PB_BYTES_ARRAY_T(256) MeshPacket_encrypted_t;
/* A packet envelope sent/received over the mesh
 only payload_variant is sent in the payload portion of the LORA packet.
 The other fields are either not sent at all, or sent in the special 16 byte LORA header. */
typedef struct _MeshPacket {
    /* The sending node number.
 Note: Our crypto implementation uses this field as well.
 See [crypto](/docs/overview/encryption) for details.
 FIXME - really should be fixed32 instead, this encoding only hurts the ble link though. */
    uint32_t from;
    /* The (immediatSee Priority description for more details.y should be fixed32 instead, this encoding only
 hurts the ble link though. */
    uint32_t to;
    /* (Usually) If set, this indicates the index in the secondary_channels table that this packet was sent/received on.
 If unset, packet was on the primary channel.
 A particular node might know only a subset of channels in use on the mesh.
 Therefore channel_index is inherently a local concept and meaningless to send between nodes.
 Very briefly, while sending and receiving deep inside the device Router code, this field instead
 contains the 'channel hash' instead of the index.
 This 'trick' is only used while the payload_variant is an 'encrypted'. */
    uint8_t channel;
    pb_size_t which_payload_variant;
    union {
        /* TODO: REPLACE */
        Data decoded;
        /* TODO: REPLACE */
        MeshPacket_encrypted_t encrypted;
    };
    /* A unique ID for this packet.
 Always 0 for no-ack packets or non broadcast packets (and therefore take zero bytes of space).
 Otherwise a unique ID for this packet, useful for flooding algorithms.
 ID only needs to be unique on a _per sender_ basis, and it only
 needs to be unique for a few minutes (long enough to last for the length of
 any ACK or the completion of a mesh broadcast flood).
 Note: Our crypto implementation uses this id as well.
 See [crypto](/docs/overview/encryption) for details.
 FIXME - really should be fixed32 instead, this encoding only
 hurts the ble link though. */
    uint32_t id;
    /* The time this message was received by the esp32 (secs since 1970).
 Note: this field is _never_ sent on the radio link itself (to save space) Times
 are typically not sent over the mesh, but they will be added to any Packet
 (chain of SubPacket) sent to the phone (so the phone can know exact time of reception) */
    uint32_t rx_time;
    /* *Never* sent over the radio links.
 Set during reception to indicate the SNR of this packet.
 Used to collect statistics on current link quality. */
    float rx_snr;
    /* If unset treated as zero (no forwarding, send to adjacent nodes only)
 if 1, allow hopping through one node, etc...
 For our usecase real world topologies probably have a max of about 3.
 This field is normally placed into a few of bits in the header. */
    uint8_t hop_limit;
    /* This packet is being sent as a reliable message, we would prefer it to arrive at the destination.
 We would like to receive a ack packet in response.
 Broadcasts messages treat this flag specially: Since acks for broadcasts would
 rapidly flood the channel, the normal ack behavior is suppressed.
 Instead, the original sender listens to see if at least one node is rebroadcasting this packet (because naive flooding algorithm).
 If it hears that the odds (given typical LoRa topologies) the odds are very high that every node should eventually receive the message.
 So FloodingRouter.cpp generates an implicit ack which is delivered to the original sender.
 If after some time we don't hear anyone rebroadcast our packet, we will timeout and retransmit, using the regular resend logic.
 Note: This flag is normally sent in a flag bit in the header when sent over the wire */
    bool want_ack;
    /* The priority of this message for sending.
 See MeshPacket.Priority description for more details. */
    MeshPacket_Priority priority;
    /* rssi of received packet. Only sent to phone for dispay purposes. */
    int32_t rx_rssi;
    /* Describe if this message is delayed */
    MeshPacket_Delayed delayed;
} MeshPacket;

/* The bluetooth to device link:
 Old BTLE protocol docs from TODO, merge in above and make real docs...
 use protocol buffers, and NanoPB
 messages from device to phone:
 POSITION_UPDATE (..., time)
 TEXT_RECEIVED(from, text, time)
 OPAQUE_RECEIVED(from, payload, time) (for signal messages or other applications)
 messages from phone to device:
 SET_MYID(id, human readable long, human readable short) (send down the unique ID
 string used for this node, a human readable string shown for that id, and a very
 short human readable string suitable for oled screen) SEND_OPAQUE(dest, payload)
 (for signal messages or other applications) SEND_TEXT(dest, text) Get all
 nodes() (returns list of nodes, with full info, last time seen, loc, battery
 level etc) SET_CONFIG (switches device to a new set of radio params and
 preshared key, drops all existing nodes, force our node to rejoin this new group)
 Full information about a node on the mesh */
typedef struct _NodeInfo {
    /* The node number */
    uint32_t num;
    /* The user info for this node */
    bool has_user;
    User user;
    /* This position data. Note: before 1.2.14 we would also store the last time we've heard from this node in position.time, that is no longer true.
 Position.time now indicates the last time we received a POSITION from that node. */
    bool has_position;
    Position position;
    /* Returns the Signal-to-noise ratio (SNR) of the last received message,
 as measured by the receiver. Return SNR of the last received message in dB */
    float snr;
    /* Set to indicate the last time we received a packet from this node */
    uint32_t last_heard;
    /* The latest device metrics for the node. */
    bool has_device_metrics;
    DeviceMetrics device_metrics;
} NodeInfo;

/* Unique local debugging info for this node
 Note: we don't include position or the user info, because that will come in the
 Sent to the phone in response to WantNodes. */
typedef struct _MyNodeInfo {
    /* Tells the phone what our node number is, default starting value is
 lowbyte of macaddr, but it will be fixed if that is already in use */
    uint32_t my_node_num;
    /* Note: This flag merely means we detected a hardware GPS in our node.
 Not the same as UserPreferences.location_sharing */
    bool has_gps;
    /* The maximum number of 'software' channels that can be set on this node. */
    uint32_t max_channels;
    /* 0.0.5 etc... */
    char firmware_version[18];
    /* An error message we'd like to report back to the mothership through analytics.
 It indicates a serious bug occurred on the device, the device coped with it,
 but we still want to tell the devs about the bug.
 This field will be cleared after the phone reads MyNodeInfo
 (i.e. it will only be reported once)
 a numeric error code to go with error message, zero means no error */
    CriticalErrorCode error_code;
    /* A numeric error address (nonzero if available) */
    uint32_t error_address;
    /* The total number of errors this node has ever encountered
 (well - since the last time we discarded preferences) */
    uint32_t error_count;
    /* The total number of reboots this node has ever encountered
 (well - since the last time we discarded preferences) */
    uint32_t reboot_count;
    /* Calculated bitrate of the current channel (in Bytes Per Second) */
    float bitrate;
    /* How long before we consider a message abandoned and we can clear our
 caches of any messages in flight Normally quite large to handle the worst case
 message delivery time, 5 minutes.
 Formerly called FLOOD_EXPIRE_TIME in the device code */
    uint32_t message_timeout_msec;
    /* The minimum app version that can talk to this device.
 Phone/PC apps should compare this to their build number and if too low tell the user they must update their app */
    uint32_t min_app_version;
    /* 24 time windows of 1hr each with the airtime transmitted out of the device per hour. */
    pb_size_t air_period_tx_count;
    uint32_t air_period_tx[8];
    /* 24 time windows of 1hr each with the airtime of valid packets for your mesh. */
    pb_size_t air_period_rx_count;
    uint32_t air_period_rx[8];
    /* Is the device wifi capable? */
    bool has_wifi;
    /* Utilization for the current channel, including well formed TX, RX and malformed RX (aka noise). */
    float channel_utilization;
    /* Percent of airtime for transmission used within the last hour. */
    float air_util_tx;
} MyNodeInfo;

/* Debug output from the device.
 To minimize the size of records inside the device code, if a time/source/level is not set
 on the message it is assumed to be a continuation of the previously sent message.
 This allows the device code to use fixed maxlen 64 byte strings for messages,
 and then extend as needed by emitting multiple records. */
typedef struct _LogRecord {
    /* Log levels, chosen to match python logging conventions. */
    char message[64];
    /* Seconds since 1970 - or 0 for unknown/unset */
    uint32_t time;
    /* Usually based on thread name - if known */
    char source[8];
    /* Not yet set */
    LogRecord_Level level;
} LogRecord;

/* Packets from the radio to the phone will appear on the fromRadio characteristic.
 It will support READ and NOTIFY. When a new packet arrives the device will BLE notify?
 It will sit in that descriptor until consumed by the phone,
 at which point the next item in the FIFO will be populated. */
typedef struct _FromRadio {
    /* The packet id, used to allow the phone to request missing read packets from the FIFO,
 see our bluetooth docs */
    uint32_t id;
    pb_size_t which_payload_variant;
    union {
        /* Log levels, chosen to match python logging conventions. */
        MeshPacket packet;
        /* Tells the phone what our node number is, can be -1 if we've not yet joined a mesh.
     NOTE: This ID must not change - to keep (minimal) compatibility with <1.2 version of android apps. */
        MyNodeInfo my_info;
        /* One packet is sent for each node in the on radio DB
     starts over with the first node in our DB */
        NodeInfo node_info;
        /* Include a part of the config (was: RadioConfig radio) */
        Config config;
        /* Set to send debug console output over our protobuf stream */
        LogRecord log_record;
        /* Sent as true once the device has finished sending all of the responses to want_config
     recipient should check if this ID matches our original request nonce, if
     not, it means your config responses haven't started yet.
     NOTE: This ID must not change - to keep (minimal) compatibility with <1.2 version of android apps. */
        uint32_t config_complete_id;
        /* Sent to tell clients the radio has just rebooted.
     Set to true if present.
     Not used on all transports, currently just used for the serial console.
     NOTE: This ID must not change - to keep (minimal) compatibility with <1.2 version of android apps. */
        bool rebooted;
        /* Include module config */
        ModuleConfig moduleConfig;
        /* One packet is sent for each channel */
        Channel channel;
    };
} FromRadio;

/* Packets/commands to the radio will be written (reliably) to the toRadio characteristic.
 Once the write completes the phone can assume it is handled. */
typedef struct _ToRadio {
    pb_size_t which_payload_variant;
    union {
        /* Send this packet on the mesh */
        MeshPacket packet;
        /* Phone wants radio to send full node db to the phone, This is
     typically the first packet sent to the radio when the phone gets a
     bluetooth connection. The radio will respond by sending back a
     MyNodeInfo, a owner, a radio config and a series of
     FromRadio.node_infos, and config_complete
     the integer you write into this field will be reported back in the
     config_complete_id response this allows clients to never be confused by
     a stale old partially sent config. */
        uint32_t want_config_id;
        /* Tell API server we are disconnecting now.
     This is useful for serial links where there is no hardware/protocol based notification that the client has dropped the link.
     (Sending this message is optional for clients) */
        bool disconnect;
    };
} ToRadio;

typedef PB_BYTES_ARRAY_T(237) Compressed_data_t;
/* Compressed message payload */
typedef struct _Compressed {
    /* PortNum to determine the how to handle the compressed payload. */
    PortNum portnum;
    /* Compressed data. */
    Compressed_data_t data;
} Compressed;


#ifdef __cplusplus
extern "C" {
#endif

/* Helper constants for enums */
#define _HardwareModel_MIN HardwareModel_UNSET
#define _HardwareModel_MAX HardwareModel_PRIVATE_HW
#define _HardwareModel_ARRAYSIZE ((HardwareModel)(HardwareModel_PRIVATE_HW+1))

#define _Constants_MIN Constants_ZERO
#define _Constants_MAX Constants_DATA_PAYLOAD_LEN
#define _Constants_ARRAYSIZE ((Constants)(Constants_DATA_PAYLOAD_LEN+1))

#define _CriticalErrorCode_MIN CriticalErrorCode_NONE
#define _CriticalErrorCode_MAX CriticalErrorCode_RADIO_SPI_BUG
#define _CriticalErrorCode_ARRAYSIZE ((CriticalErrorCode)(CriticalErrorCode_RADIO_SPI_BUG+1))

#define _Position_LocSource_MIN Position_LocSource_LOC_UNSET
#define _Position_LocSource_MAX Position_LocSource_LOC_EXTERNAL
#define _Position_LocSource_ARRAYSIZE ((Position_LocSource)(Position_LocSource_LOC_EXTERNAL+1))

#define _Position_AltSource_MIN Position_AltSource_ALT_UNSET
#define _Position_AltSource_MAX Position_AltSource_ALT_BAROMETRIC
#define _Position_AltSource_ARRAYSIZE ((Position_AltSource)(Position_AltSource_ALT_BAROMETRIC+1))

#define _Routing_Error_MIN Routing_Error_NONE
#define _Routing_Error_MAX Routing_Error_NOT_AUTHORIZED
#define _Routing_Error_ARRAYSIZE ((Routing_Error)(Routing_Error_NOT_AUTHORIZED+1))

#define _MeshPacket_Priority_MIN MeshPacket_Priority_UNSET
#define _MeshPacket_Priority_MAX MeshPacket_Priority_MAX
#define _MeshPacket_Priority_ARRAYSIZE ((MeshPacket_Priority)(MeshPacket_Priority_MAX+1))

#define _MeshPacket_Delayed_MIN MeshPacket_Delayed_NO_DELAY
#define _MeshPacket_Delayed_MAX MeshPacket_Delayed_DELAYED_DIRECT
#define _MeshPacket_Delayed_ARRAYSIZE ((MeshPacket_Delayed)(MeshPacket_Delayed_DELAYED_DIRECT+1))

#define _LogRecord_Level_MIN LogRecord_Level_UNSET
#define _LogRecord_Level_MAX LogRecord_Level_CRITICAL
#define _LogRecord_Level_ARRAYSIZE ((LogRecord_Level)(LogRecord_Level_CRITICAL+1))

#define Position_location_source_ENUMTYPE Position_LocSource
#define Position_altitude_source_ENUMTYPE Position_AltSource

#define User_hw_model_ENUMTYPE HardwareModel


#define Routing_variant_error_reason_ENUMTYPE Routing_Error

#define Data_portnum_ENUMTYPE PortNum


#define MeshPacket_priority_ENUMTYPE MeshPacket_Priority
#define MeshPacket_delayed_ENUMTYPE MeshPacket_Delayed


#define MyNodeInfo_error_code_ENUMTYPE CriticalErrorCode

#define LogRecord_level_ENUMTYPE LogRecord_Level



#define Compressed_portnum_ENUMTYPE PortNum


/* Initializer values for message structs */
#define Position_init_default                    {0, 0, 0, 0, _Position_LocSource_MIN, _Position_AltSource_MIN, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}
#define User_init_default                        {"", "", "", {0}, _HardwareModel_MIN, 0}
#define RouteDiscovery_init_default              {0, {0, 0, 0, 0, 0, 0, 0, 0}}
#define Routing_init_default                     {0, {RouteDiscovery_init_default}}
#define Data_init_default                        {_PortNum_MIN, {0, {0}}, 0, 0, 0, 0, 0, 0}
#define Waypoint_init_default                    {0, 0, 0, 0, 0, "", ""}
#define MeshPacket_init_default                  {0, 0, 0, 0, {Data_init_default}, 0, 0, 0, 0, 0, _MeshPacket_Priority_MIN, 0, _MeshPacket_Delayed_MIN}
#define NodeInfo_init_default                    {0, false, User_init_default, false, Position_init_default, 0, 0, false, DeviceMetrics_init_default}
#define MyNodeInfo_init_default                  {0, 0, 0, "", _CriticalErrorCode_MIN, 0, 0, 0, 0, 0, 0, 0, {0, 0, 0, 0, 0, 0, 0, 0}, 0, {0, 0, 0, 0, 0, 0, 0, 0}, 0, 0, 0}
#define LogRecord_init_default                   {"", 0, "", _LogRecord_Level_MIN}
#define FromRadio_init_default                   {0, 0, {MeshPacket_init_default}}
#define ToRadio_init_default                     {0, {MeshPacket_init_default}}
#define Compressed_init_default                  {_PortNum_MIN, {0, {0}}}
#define Position_init_zero                       {0, 0, 0, 0, _Position_LocSource_MIN, _Position_AltSource_MIN, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}
#define User_init_zero                           {"", "", "", {0}, _HardwareModel_MIN, 0}
#define RouteDiscovery_init_zero                 {0, {0, 0, 0, 0, 0, 0, 0, 0}}
#define Routing_init_zero                        {0, {RouteDiscovery_init_zero}}
#define Data_init_zero                           {_PortNum_MIN, {0, {0}}, 0, 0, 0, 0, 0, 0}
#define Waypoint_init_zero                       {0, 0, 0, 0, 0, "", ""}
#define MeshPacket_init_zero                     {0, 0, 0, 0, {Data_init_zero}, 0, 0, 0, 0, 0, _MeshPacket_Priority_MIN, 0, _MeshPacket_Delayed_MIN}
#define NodeInfo_init_zero                       {0, false, User_init_zero, false, Position_init_zero, 0, 0, false, DeviceMetrics_init_zero}
#define MyNodeInfo_init_zero                     {0, 0, 0, "", _CriticalErrorCode_MIN, 0, 0, 0, 0, 0, 0, 0, {0, 0, 0, 0, 0, 0, 0, 0}, 0, {0, 0, 0, 0, 0, 0, 0, 0}, 0, 0, 0}
#define LogRecord_init_zero                      {"", 0, "", _LogRecord_Level_MIN}
#define FromRadio_init_zero                      {0, 0, {MeshPacket_init_zero}}
#define ToRadio_init_zero                        {0, {MeshPacket_init_zero}}
#define Compressed_init_zero                     {_PortNum_MIN, {0, {0}}}

/* Field tags (for use in manual encoding/decoding) */
#define Position_latitude_i_tag                  1
#define Position_longitude_i_tag                 2
#define Position_altitude_tag                    3
#define Position_time_tag                        4
#define Position_location_source_tag             5
#define Position_altitude_source_tag             6
#define Position_timestamp_tag                   7
#define Position_timestamp_millis_adjust_tag     8
#define Position_altitude_hae_tag                9
#define Position_altitude_geoidal_separation_tag 10
#define Position_PDOP_tag                        11
#define Position_HDOP_tag                        12
#define Position_VDOP_tag                        13
#define Position_gps_accuracy_tag                14
#define Position_ground_speed_tag                15
#define Position_ground_track_tag                16
#define Position_fix_quality_tag                 17
#define Position_fix_type_tag                    18
#define Position_sats_in_view_tag                19
#define Position_sensor_id_tag                   20
#define Position_next_update_tag                 21
#define Position_seq_number_tag                  22
#define User_id_tag                              1
#define User_long_name_tag                       2
#define User_short_name_tag                      3
#define User_macaddr_tag                         4
#define User_hw_model_tag                        5
#define User_is_licensed_tag                     6
#define RouteDiscovery_route_tag                 1
#define Routing_route_request_tag                1
#define Routing_route_reply_tag                  2
#define Routing_error_reason_tag                 3
#define Data_portnum_tag                         1
#define Data_payload_tag                         2
#define Data_want_response_tag                   3
#define Data_dest_tag                            4
#define Data_source_tag                          5
#define Data_request_id_tag                      6
#define Data_reply_id_tag                        7
#define Data_emoji_tag                           8
#define Waypoint_id_tag                          1
#define Waypoint_latitude_i_tag                  2
#define Waypoint_longitude_i_tag                 3
#define Waypoint_expire_tag                      4
#define Waypoint_locked_tag                      5
#define Waypoint_name_tag                        6
#define Waypoint_description_tag                 7
#define MeshPacket_from_tag                      1
#define MeshPacket_to_tag                        2
#define MeshPacket_channel_tag                   3
#define MeshPacket_decoded_tag                   4
#define MeshPacket_encrypted_tag                 5
#define MeshPacket_id_tag                        6
#define MeshPacket_rx_time_tag                   7
#define MeshPacket_rx_snr_tag                    8
#define MeshPacket_hop_limit_tag                 9
#define MeshPacket_want_ack_tag                  10
#define MeshPacket_priority_tag                  11
#define MeshPacket_rx_rssi_tag                   12
#define MeshPacket_delayed_tag                   13
#define NodeInfo_num_tag                         1
#define NodeInfo_user_tag                        2
#define NodeInfo_position_tag                    3
#define NodeInfo_snr_tag                         4
#define NodeInfo_last_heard_tag                  5
#define NodeInfo_device_metrics_tag              6
#define MyNodeInfo_my_node_num_tag               1
#define MyNodeInfo_has_gps_tag                   2
#define MyNodeInfo_max_channels_tag              3
#define MyNodeInfo_firmware_version_tag          4
#define MyNodeInfo_error_code_tag                5
#define MyNodeInfo_error_address_tag             6
#define MyNodeInfo_error_count_tag               7
#define MyNodeInfo_reboot_count_tag              8
#define MyNodeInfo_bitrate_tag                   9
#define MyNodeInfo_message_timeout_msec_tag      10
#define MyNodeInfo_min_app_version_tag           11
#define MyNodeInfo_air_period_tx_tag             12
#define MyNodeInfo_air_period_rx_tag             13
#define MyNodeInfo_has_wifi_tag                  14
#define MyNodeInfo_channel_utilization_tag       15
#define MyNodeInfo_air_util_tx_tag               16
#define LogRecord_message_tag                    1
#define LogRecord_time_tag                       2
#define LogRecord_source_tag                     3
#define LogRecord_level_tag                      4
#define FromRadio_id_tag                         1
#define FromRadio_packet_tag                     2
#define FromRadio_my_info_tag                    3
#define FromRadio_node_info_tag                  4
#define FromRadio_config_tag                     5
#define FromRadio_log_record_tag                 6
#define FromRadio_config_complete_id_tag         7
#define FromRadio_rebooted_tag                   8
#define FromRadio_moduleConfig_tag               9
#define FromRadio_channel_tag                    10
#define ToRadio_packet_tag                       1
#define ToRadio_want_config_id_tag               3
#define ToRadio_disconnect_tag                   4
#define Compressed_portnum_tag                   1
#define Compressed_data_tag                      2

/* Struct field encoding specification for nanopb */
#define Position_FIELDLIST(X, a) \
X(a, STATIC,   SINGULAR, SFIXED32, latitude_i,        1) \
X(a, STATIC,   SINGULAR, SFIXED32, longitude_i,       2) \
X(a, STATIC,   SINGULAR, INT32,    altitude,          3) \
X(a, STATIC,   SINGULAR, FIXED32,  time,              4) \
X(a, STATIC,   SINGULAR, UENUM,    location_source,   5) \
X(a, STATIC,   SINGULAR, UENUM,    altitude_source,   6) \
X(a, STATIC,   SINGULAR, FIXED32,  timestamp,         7) \
X(a, STATIC,   SINGULAR, INT32,    timestamp_millis_adjust,   8) \
X(a, STATIC,   SINGULAR, SINT32,   altitude_hae,      9) \
X(a, STATIC,   SINGULAR, SINT32,   altitude_geoidal_separation,  10) \
X(a, STATIC,   SINGULAR, UINT32,   PDOP,             11) \
X(a, STATIC,   SINGULAR, UINT32,   HDOP,             12) \
X(a, STATIC,   SINGULAR, UINT32,   VDOP,             13) \
X(a, STATIC,   SINGULAR, UINT32,   gps_accuracy,     14) \
X(a, STATIC,   SINGULAR, UINT32,   ground_speed,     15) \
X(a, STATIC,   SINGULAR, UINT32,   ground_track,     16) \
X(a, STATIC,   SINGULAR, UINT32,   fix_quality,      17) \
X(a, STATIC,   SINGULAR, UINT32,   fix_type,         18) \
X(a, STATIC,   SINGULAR, UINT32,   sats_in_view,     19) \
X(a, STATIC,   SINGULAR, UINT32,   sensor_id,        20) \
X(a, STATIC,   SINGULAR, UINT32,   next_update,      21) \
X(a, STATIC,   SINGULAR, UINT32,   seq_number,       22)
#define Position_CALLBACK NULL
#define Position_DEFAULT NULL

#define User_FIELDLIST(X, a) \
X(a, STATIC,   SINGULAR, STRING,   id,                1) \
X(a, STATIC,   SINGULAR, STRING,   long_name,         2) \
X(a, STATIC,   SINGULAR, STRING,   short_name,        3) \
X(a, STATIC,   SINGULAR, FIXED_LENGTH_BYTES, macaddr,           4) \
X(a, STATIC,   SINGULAR, UENUM,    hw_model,          5) \
X(a, STATIC,   SINGULAR, BOOL,     is_licensed,       6)
#define User_CALLBACK NULL
#define User_DEFAULT NULL

#define RouteDiscovery_FIELDLIST(X, a) \
X(a, STATIC,   REPEATED, FIXED32,  route,             1)
#define RouteDiscovery_CALLBACK NULL
#define RouteDiscovery_DEFAULT NULL

#define Routing_FIELDLIST(X, a) \
X(a, STATIC,   ONEOF,    MESSAGE,  (variant,route_request,route_request),   1) \
X(a, STATIC,   ONEOF,    MESSAGE,  (variant,route_reply,route_reply),   2) \
X(a, STATIC,   ONEOF,    UENUM,    (variant,error_reason,error_reason),   3)
#define Routing_CALLBACK NULL
#define Routing_DEFAULT NULL
#define Routing_variant_route_request_MSGTYPE RouteDiscovery
#define Routing_variant_route_reply_MSGTYPE RouteDiscovery

#define Data_FIELDLIST(X, a) \
X(a, STATIC,   SINGULAR, UENUM,    portnum,           1) \
X(a, STATIC,   SINGULAR, BYTES,    payload,           2) \
X(a, STATIC,   SINGULAR, BOOL,     want_response,     3) \
X(a, STATIC,   SINGULAR, FIXED32,  dest,              4) \
X(a, STATIC,   SINGULAR, FIXED32,  source,            5) \
X(a, STATIC,   SINGULAR, FIXED32,  request_id,        6) \
X(a, STATIC,   SINGULAR, FIXED32,  reply_id,          7) \
X(a, STATIC,   SINGULAR, FIXED32,  emoji,             8)
#define Data_CALLBACK NULL
#define Data_DEFAULT NULL

#define Waypoint_FIELDLIST(X, a) \
X(a, STATIC,   SINGULAR, UINT32,   id,                1) \
X(a, STATIC,   SINGULAR, SFIXED32, latitude_i,        2) \
X(a, STATIC,   SINGULAR, SFIXED32, longitude_i,       3) \
X(a, STATIC,   SINGULAR, UINT32,   expire,            4) \
X(a, STATIC,   SINGULAR, BOOL,     locked,            5) \
X(a, STATIC,   SINGULAR, STRING,   name,              6) \
X(a, STATIC,   SINGULAR, STRING,   description,       7)
#define Waypoint_CALLBACK NULL
#define Waypoint_DEFAULT NULL

#define MeshPacket_FIELDLIST(X, a) \
X(a, STATIC,   SINGULAR, FIXED32,  from,              1) \
X(a, STATIC,   SINGULAR, FIXED32,  to,                2) \
X(a, STATIC,   SINGULAR, UINT32,   channel,           3) \
X(a, STATIC,   ONEOF,    MESSAGE,  (payload_variant,decoded,decoded),   4) \
X(a, STATIC,   ONEOF,    BYTES,    (payload_variant,encrypted,encrypted),   5) \
X(a, STATIC,   SINGULAR, FIXED32,  id,                6) \
X(a, STATIC,   SINGULAR, FIXED32,  rx_time,           7) \
X(a, STATIC,   SINGULAR, FLOAT,    rx_snr,            8) \
X(a, STATIC,   SINGULAR, UINT32,   hop_limit,         9) \
X(a, STATIC,   SINGULAR, BOOL,     want_ack,         10) \
X(a, STATIC,   SINGULAR, UENUM,    priority,         11) \
X(a, STATIC,   SINGULAR, INT32,    rx_rssi,          12) \
X(a, STATIC,   SINGULAR, UENUM,    delayed,          13)
#define MeshPacket_CALLBACK NULL
#define MeshPacket_DEFAULT NULL
#define MeshPacket_payload_variant_decoded_MSGTYPE Data

#define NodeInfo_FIELDLIST(X, a) \
X(a, STATIC,   SINGULAR, UINT32,   num,               1) \
X(a, STATIC,   OPTIONAL, MESSAGE,  user,              2) \
X(a, STATIC,   OPTIONAL, MESSAGE,  position,          3) \
X(a, STATIC,   SINGULAR, FLOAT,    snr,               4) \
X(a, STATIC,   SINGULAR, FIXED32,  last_heard,        5) \
X(a, STATIC,   OPTIONAL, MESSAGE,  device_metrics,    6)
#define NodeInfo_CALLBACK NULL
#define NodeInfo_DEFAULT NULL
#define NodeInfo_user_MSGTYPE User
#define NodeInfo_position_MSGTYPE Position
#define NodeInfo_device_metrics_MSGTYPE DeviceMetrics

#define MyNodeInfo_FIELDLIST(X, a) \
X(a, STATIC,   SINGULAR, UINT32,   my_node_num,       1) \
X(a, STATIC,   SINGULAR, BOOL,     has_gps,           2) \
X(a, STATIC,   SINGULAR, UINT32,   max_channels,      3) \
X(a, STATIC,   SINGULAR, STRING,   firmware_version,   4) \
X(a, STATIC,   SINGULAR, UENUM,    error_code,        5) \
X(a, STATIC,   SINGULAR, UINT32,   error_address,     6) \
X(a, STATIC,   SINGULAR, UINT32,   error_count,       7) \
X(a, STATIC,   SINGULAR, UINT32,   reboot_count,      8) \
X(a, STATIC,   SINGULAR, FLOAT,    bitrate,           9) \
X(a, STATIC,   SINGULAR, UINT32,   message_timeout_msec,  10) \
X(a, STATIC,   SINGULAR, UINT32,   min_app_version,  11) \
X(a, STATIC,   REPEATED, UINT32,   air_period_tx,    12) \
X(a, STATIC,   REPEATED, UINT32,   air_period_rx,    13) \
X(a, STATIC,   SINGULAR, BOOL,     has_wifi,         14) \
X(a, STATIC,   SINGULAR, FLOAT,    channel_utilization,  15) \
X(a, STATIC,   SINGULAR, FLOAT,    air_util_tx,      16)
#define MyNodeInfo_CALLBACK NULL
#define MyNodeInfo_DEFAULT NULL

#define LogRecord_FIELDLIST(X, a) \
X(a, STATIC,   SINGULAR, STRING,   message,           1) \
X(a, STATIC,   SINGULAR, FIXED32,  time,              2) \
X(a, STATIC,   SINGULAR, STRING,   source,            3) \
X(a, STATIC,   SINGULAR, UENUM,    level,             4)
#define LogRecord_CALLBACK NULL
#define LogRecord_DEFAULT NULL

#define FromRadio_FIELDLIST(X, a) \
X(a, STATIC,   SINGULAR, UINT32,   id,                1) \
X(a, STATIC,   ONEOF,    MESSAGE,  (payload_variant,packet,packet),   2) \
X(a, STATIC,   ONEOF,    MESSAGE,  (payload_variant,my_info,my_info),   3) \
X(a, STATIC,   ONEOF,    MESSAGE,  (payload_variant,node_info,node_info),   4) \
X(a, STATIC,   ONEOF,    MESSAGE,  (payload_variant,config,config),   5) \
X(a, STATIC,   ONEOF,    MESSAGE,  (payload_variant,log_record,log_record),   6) \
X(a, STATIC,   ONEOF,    UINT32,   (payload_variant,config_complete_id,config_complete_id),   7) \
X(a, STATIC,   ONEOF,    BOOL,     (payload_variant,rebooted,rebooted),   8) \
X(a, STATIC,   ONEOF,    MESSAGE,  (payload_variant,moduleConfig,moduleConfig),   9) \
X(a, STATIC,   ONEOF,    MESSAGE,  (payload_variant,channel,channel),  10)
#define FromRadio_CALLBACK NULL
#define FromRadio_DEFAULT NULL
#define FromRadio_payload_variant_packet_MSGTYPE MeshPacket
#define FromRadio_payload_variant_my_info_MSGTYPE MyNodeInfo
#define FromRadio_payload_variant_node_info_MSGTYPE NodeInfo
#define FromRadio_payload_variant_config_MSGTYPE Config
#define FromRadio_payload_variant_log_record_MSGTYPE LogRecord
#define FromRadio_payload_variant_moduleConfig_MSGTYPE ModuleConfig
#define FromRadio_payload_variant_channel_MSGTYPE Channel

#define ToRadio_FIELDLIST(X, a) \
X(a, STATIC,   ONEOF,    MESSAGE,  (payload_variant,packet,packet),   1) \
X(a, STATIC,   ONEOF,    UINT32,   (payload_variant,want_config_id,want_config_id),   3) \
X(a, STATIC,   ONEOF,    BOOL,     (payload_variant,disconnect,disconnect),   4)
#define ToRadio_CALLBACK NULL
#define ToRadio_DEFAULT NULL
#define ToRadio_payload_variant_packet_MSGTYPE MeshPacket

#define Compressed_FIELDLIST(X, a) \
X(a, STATIC,   SINGULAR, UENUM,    portnum,           1) \
X(a, STATIC,   SINGULAR, BYTES,    data,              2)
#define Compressed_CALLBACK NULL
#define Compressed_DEFAULT NULL

extern const pb_msgdesc_t Position_msg;
extern const pb_msgdesc_t User_msg;
extern const pb_msgdesc_t RouteDiscovery_msg;
extern const pb_msgdesc_t Routing_msg;
extern const pb_msgdesc_t Data_msg;
extern const pb_msgdesc_t Waypoint_msg;
extern const pb_msgdesc_t MeshPacket_msg;
extern const pb_msgdesc_t NodeInfo_msg;
extern const pb_msgdesc_t MyNodeInfo_msg;
extern const pb_msgdesc_t LogRecord_msg;
extern const pb_msgdesc_t FromRadio_msg;
extern const pb_msgdesc_t ToRadio_msg;
extern const pb_msgdesc_t Compressed_msg;

/* Defines for backwards compatibility with code written before nanopb-0.4.0 */
#define Position_fields &Position_msg
#define User_fields &User_msg
#define RouteDiscovery_fields &RouteDiscovery_msg
#define Routing_fields &Routing_msg
#define Data_fields &Data_msg
#define Waypoint_fields &Waypoint_msg
#define MeshPacket_fields &MeshPacket_msg
#define NodeInfo_fields &NodeInfo_msg
#define MyNodeInfo_fields &MyNodeInfo_msg
#define LogRecord_fields &LogRecord_msg
#define FromRadio_fields &FromRadio_msg
#define ToRadio_fields &ToRadio_msg
#define Compressed_fields &Compressed_msg

/* Maximum encoded size of messages (where known) */
#define Compressed_size                          243
#define Data_size                                270
#define FromRadio_size                           330
#define LogRecord_size                           81
#define MeshPacket_size                          321
#define MyNodeInfo_size                          179
#define NodeInfo_size                            258
#define Position_size                            137
#define RouteDiscovery_size                      40
#define Routing_size                             42
#define ToRadio_size                             324
#define User_size                                77
#define Waypoint_size                            156

#ifdef __cplusplus
} /* extern "C" */
#endif

#endif
